/**
 * File: /src/graphRepository.ts
 * Project: apache-age-client
 * File Created: 13-09-2022 05:34:30
 * Author: Apache Software Foundation
 * -----
 * Last Modified: 13-09-2022 07:56:39
 * Modified By: Clay Risser
 * -----
 * Risser Labs LLC (c) Copyright 2022
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import pg from "pg";
import types from "pg-types";
import { flavors, pg as pgConfig } from "./config";
import { setAgeTypes } from "./tools/ageParser";
export class GraphRepository {
  constructor() {
    let {
      host,
      port,
      database,
      graph,
      user,
      password,
      flavor
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    this.flavor = void 0;
    this._database = void 0;
    this._graph = void 0;
    this._host = void 0;
    this._password = void 0;
    this._pool = void 0;
    this._port = void 0;
    this._user = void 0;
    this._host = host;
    this._port = port;
    this._database = database;
    this._graph = graph;
    this._user = user;
    this._password = password;
    this.flavor = flavor || flavors.AGE;
  }

  static async getConnection() {
    let {
      database,
      flavor,
      host,
      password,
      port,
      user
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    let closeConnection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    const client = new pg.Client({
      user,
      password,
      host,
      database,
      port
    });
    client.connect();

    if (flavor === flavors.AGE) {
      await setAgeTypes(client, types);
    } else {
      throw new Error(`unknown flavor ${flavor}`);
    }

    if (closeConnection === true) await client.end();
    return client;
  }

  static newConnectionPool(poolConnectionConfig) {
    return new pg.Pool(poolConnectionConfig);
  }

  async execute(query) {
    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    const client = await this.getConnection();
    let result = null;

    try {
      result = await client.query(query, params);
    } catch (err) {
      throw err;
    } finally {
      client.release();
    }

    return result;
  }

  async getConnection() {
    if (!this._pool) {
      this._pool = GraphRepository.newConnectionPool(this.getPoolConnectionInfo());
    }

    const client = await this._pool.connect();

    if (this.flavor === "AGE") {
      await setAgeTypes(client, types);
    } else {
      await client.query(`set graph_path = ${this._graph}`);
    }

    return client;
  }

  async releaseConnection() {
    try {
      if (this._pool) await this._pool.end();
      return true;
    } catch (err) {
      throw err;
    }
  }

  getPoolConnectionInfo() {
    if (!this._host || !this._port || !this._database) {
      throw new Error("missing connection config");
    }

    return {
      connectionTimeoutMillis: pgConfig.connectionTimeoutMillis,
      database: this._database,
      host: this._host,
      idleTimeoutMillis: pgConfig.idleTimeoutMillis,
      max: pgConfig.max,
      password: this._password,
      port: this._port,
      user: this._user
    };
  }

  getConnectionInfo() {
    if (!this._host || !this._port || !this._database) {
      throw new Error("not connected");
    }

    return {
      host: this._host,
      port: this._port,
      database: this._database,
      user: this._user,
      password: this._password,
      graph: this._graph,
      flavor: this.flavor
    };
  }

  get graph() {
    return this._graph;
  }

}
//# sourceMappingURL=graphRepository.js.map