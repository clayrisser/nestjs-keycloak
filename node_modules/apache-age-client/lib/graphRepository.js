(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "pg", "pg-types", "./config", "./tools/ageParser"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("pg"), require("pg-types"), require("./config"), require("./tools/ageParser"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.pg, global.pgTypes, global.config, global.ageParser);
    global.graphRepository = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _pg, _pgTypes, _config, _ageParser) {
  "use strict";

  var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.GraphRepository = void 0;
  _pg = _interopRequireDefault(_pg);
  _pgTypes = _interopRequireDefault(_pgTypes);

  /**
   * File: /src/graphRepository.ts
   * Project: apache-age-client
   * File Created: 13-09-2022 05:34:30
   * Author: Apache Software Foundation
   * -----
   * Last Modified: 13-09-2022 07:56:39
   * Modified By: Clay Risser
   * -----
   * Risser Labs LLC (c) Copyright 2022
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  class GraphRepository {
    constructor() {
      let {
        host,
        port,
        database,
        graph,
        user,
        password,
        flavor
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.flavor = void 0;
      this._database = void 0;
      this._graph = void 0;
      this._host = void 0;
      this._password = void 0;
      this._pool = void 0;
      this._port = void 0;
      this._user = void 0;
      this._host = host;
      this._port = port;
      this._database = database;
      this._graph = graph;
      this._user = user;
      this._password = password;
      this.flavor = flavor || _config.flavors.AGE;
    }

    static async getConnection() {
      let {
        database,
        flavor,
        host,
        password,
        port,
        user
      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      let closeConnection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      const client = new _pg.default.Client({
        user,
        password,
        host,
        database,
        port
      });
      client.connect();

      if (flavor === _config.flavors.AGE) {
        await (0, _ageParser.setAgeTypes)(client, _pgTypes.default);
      } else {
        throw new Error(`unknown flavor ${flavor}`);
      }

      if (closeConnection === true) await client.end();
      return client;
    }

    static newConnectionPool(poolConnectionConfig) {
      return new _pg.default.Pool(poolConnectionConfig);
    }

    async execute(query) {
      let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      const client = await this.getConnection();
      let result = null;

      try {
        result = await client.query(query, params);
      } catch (err) {
        throw err;
      } finally {
        client.release();
      }

      return result;
    }

    async getConnection() {
      if (!this._pool) {
        this._pool = GraphRepository.newConnectionPool(this.getPoolConnectionInfo());
      }

      const client = await this._pool.connect();

      if (this.flavor === "AGE") {
        await (0, _ageParser.setAgeTypes)(client, _pgTypes.default);
      } else {
        await client.query(`set graph_path = ${this._graph}`);
      }

      return client;
    }

    async releaseConnection() {
      try {
        if (this._pool) await this._pool.end();
        return true;
      } catch (err) {
        throw err;
      }
    }

    getPoolConnectionInfo() {
      if (!this._host || !this._port || !this._database) {
        throw new Error("missing connection config");
      }

      return {
        connectionTimeoutMillis: _config.pg.connectionTimeoutMillis,
        database: this._database,
        host: this._host,
        idleTimeoutMillis: _config.pg.idleTimeoutMillis,
        max: _config.pg.max,
        password: this._password,
        port: this._port,
        user: this._user
      };
    }

    getConnectionInfo() {
      if (!this._host || !this._port || !this._database) {
        throw new Error("not connected");
      }

      return {
        host: this._host,
        port: this._port,
        database: this._database,
        user: this._user,
        password: this._password,
        graph: this._graph,
        flavor: this.flavor
      };
    }

    get graph() {
      return this._graph;
    }

  }

  _exports.GraphRepository = GraphRepository;
});
//# sourceMappingURL=graphRepository.js.map